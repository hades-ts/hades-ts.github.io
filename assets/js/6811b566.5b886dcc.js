"use strict";(self.webpackChunk_hades_ts_docs=self.webpackChunk_hades_ts_docs||[]).push([[9124],{774:(e,n,s)=>{s.d(n,{A:()=>o});const o=s.p+"assets/images/services-92d9b5634998328ce5724d0cc5bf3d18.png"},1e3:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>g,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"using-services","title":"Using Services","description":"A component in your program - usually a class - that another component depends on for something,","source":"@site/docs/hades/using-services.md","sourceDirName":".","slug":"/using-services","permalink":"/docs/hades/using-services","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"hades","previous":{"title":"Client Events","permalink":"/docs/hades/events"},"next":{"title":"Built-in Services","permalink":"/docs/hades/services/"}}');var i=s(7282),t=s(4610);const r={},c="Using Services",a={},l=[{value:"Baby&#39;s First Service",id:"babys-first-service",level:2},{value:"Delegating to a Service",id:"delegating-to-a-service",level:3},{value:"Delegating to an Interface",id:"delegating-to-an-interface",level:3},{value:"Binding Interfaces to Services",id:"binding-interfaces-to-services",level:3},{value:"Fancy Binding Logic",id:"fancy-binding-logic",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"using-services",children:"Using Services"})}),"\n",(0,i.jsx)(n.admonition,{title:"What's a service?",type:"info",children:(0,i.jsx)(n.p,{children:"A component in your program - usually a class - that another component depends on for something,\ninstead of doing it itself."})}),"\n",(0,i.jsxs)(n.p,{children:["Bots get the most value from Hades when they adopt a ",(0,i.jsx)(n.strong,{children:"service oriented architecture"})," where we keep\nthe various parts of our programs small, doing just one thing. Instead of big components that do a\nlot, we'll prefer small components that rely on each other."]}),"\n",(0,i.jsx)(n.p,{children:"Hades excels at wiring your components automatically. This lets you focus on writing small easy to\nunderstand components while Hades fits them together for you."}),"\n",(0,i.jsxs)("center",{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"services",src:s(774).A+"",width:"555",height:"544"})}),(0,i.jsx)("figcaption",{children:(0,i.jsxs)(n.p,{children:["Learn more about ",(0,i.jsx)(n.a,{href:"/docs/guides/solid-code",children:"service oriented architecture"}),"\nand ",(0,i.jsx)(n.a,{href:"/docs/guides/di",children:"dependency injection"}),"."]})})]}),"\n",(0,i.jsx)(n.h2,{id:"babys-first-service",children:"Baby's First Service"}),"\n",(0,i.jsx)(n.p,{children:"Consider the minimal example bot:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export class BotService extends HadesBotService {\n  async onReady() {\n    console.log(`Logged in as ${this.client.user.username}.`);\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This bot is claiming for itself the responsibility for how we do logging. In this case,\n",(0,i.jsx)(n.code,{children:"console.log"})," is the logging approach taken."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"But what if we wanted to change how logging works?"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Well we just change the line!"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Sure, but if we have a lot of logging throughout a large project?"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"RIP."})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Instead, when we need to log, we should delegate to some service specialized just for that purpose."}),"\n",(0,i.jsx)(n.h3,{id:"delegating-to-a-service",children:"Delegating to a Service"}),"\n",(0,i.jsxs)(n.p,{children:["Let's define a ",(0,i.jsx)(n.code,{children:"ConsoleLogger"})," that will capture our current logging approach:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"class ConsoleLogger {\n    log(msg: string) { console.log(msg) }\n    warn(msg: string) { console.warn(msg) }\n    error(msg: string) { console.error(msg) }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Now we can delegate logging to the service:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export class BotService extends HadesBotService {\n  logger = new ConsoleLogger()\n\n  async onReady() {\n    this.logger.log(`Logged in as ${this.client.user.username}.`);\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"BotService"})," is still too picky about logging, however, deciding for itself to always use\n",(0,i.jsx)(n.code,{children:"console.log"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"delegating-to-an-interface",children:"Delegating to an Interface"}),"\n",(0,i.jsxs)(n.p,{children:["To get ",(0,i.jsx)(n.code,{children:"BotService"})," fully out of the business of making decisions about logging it should instead\ndelegate to an interface. Because real interfaces disappear at runtime (TypeScript is type-erased),\nwe'll instead use abstract classes:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export abstract class ILogger {\n    abstract log(msg: string): void\n    abstract warn(msg: string): void\n    abstract error(msg: string): void\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now the bot can declare and use an ",(0,i.jsx)(n.code,{children:"ILogger"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export class BotService extends HadesBotService {\n  @inject(ILogger)\n  logger: ILogger\n\n  async onReady() {\n    this.logger.log(`Logged in as ${this.client.user.username}.`);\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["But where does the actual logger come from? Hades! The ",(0,i.jsx)(n.code,{children:"@inject(ILogger)"})," decorator tells Hades\nwhere an ",(0,i.jsx)(n.code,{children:"ILogger"})," is expected. When ",(0,i.jsx)(n.code,{children:"BotService"})," is created, Hades will ensure that it receives\none."]}),"\n",(0,i.jsx)(n.h3,{id:"binding-interfaces-to-services",children:"Binding Interfaces to Services"}),"\n",(0,i.jsxs)(n.p,{children:["Hades knows that it needs to provide services for all ",(0,i.jsx)(n.code,{children:"@inject"})," decorated fields. But when it sees\nthat it needs to provide an ",(0,i.jsx)(n.code,{children:"ILogger"}),", it doesn't automatically know which class should be used."]}),"\n",(0,i.jsx)(n.p,{children:"So we need to tell Hades:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsxs)(n.em,{children:["Anyone who needs an ",(0,i.jsx)(n.code,{children:"ILogger"})," should get a ",(0,i.jsx)(n.code,{children:"ConsoleLogger"}),"."]})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["There are a few ways to to do that. For now we'll pass an arrow function to ",(0,i.jsx)(n.code,{children:"boot"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"boot(BotService, [\n    (container) => {\n        container\n            .bind(ILogger)\n            .to(ConsoleLogger)\n            .inSingletonScope()\n    }\n])\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"inSingletonScope()"})," ensures that everyone shares the same ",(0,i.jsx)(n.code,{children:"ConsoleLogger"})," instance."]})}),"\n",(0,i.jsxs)(n.p,{children:["Again, this tells Hades that anytime someone requests an ",(0,i.jsx)(n.code,{children:"ILogger"}),", they should be given a\n",(0,i.jsx)(n.code,{children:"ConsoleLogger"}),". We can now control how logging works for everyone in a single place."]}),"\n",(0,i.jsx)(n.h3,{id:"fancy-binding-logic",children:"Fancy Binding Logic"}),"\n",(0,i.jsx)(n.p,{children:"Now that we know how to delegate to interfaces and tell Hades which services should be bound to\nwhich interfaces we can get a bit more sophisticated."}),"\n",(0,i.jsxs)(n.p,{children:["Let's define another ",(0,i.jsx)(n.code,{children:"ILogger"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export class NullLogger extends ILogger {\n    log(msg: string) { return; }\n    warn(msg: string) { return; }\n    error(msg: string) { return; }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This logger doesn't do anything. But there could be cases where we want to disable logging entirely.\nNow that's trivial with a bit of logic in our binding function:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"boot(BotService, [\n    (container) => {\n        container\n            .bind(ILogger)\n            .to(process.env.DEBUG ? ConsoleLogger : NullLogger)\n            .inSingletonScope()\n    }\n])\n"})}),"\n",(0,i.jsxs)(n.p,{children:["With this change, logging will only be enabled when the ",(0,i.jsx)(n.code,{children:"DEBUG"})," environment variable is present. A\nservice oriented architecture removes this kind of decision making from your components, making them\nleaner - therefore clearer. Maybe in production, instead of no logging, you log to some third-party\nprovider, etc."]}),"\n",(0,i.jsx)(n.p,{children:"Hopefully you can start to see the hygiene of this approach. If you are working on your project\nbecause you think it could grow into something worthwhile, Hades could be what helps your project\nwithstand that growth."})]})}function g(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},4610:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var o=s(538);const i={},t=o.createContext(i);function r(e){const n=o.useContext(t);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);