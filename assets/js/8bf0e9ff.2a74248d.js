"use strict";(self.webpackChunk_hades_ts_docs=self.webpackChunk_hades_ts_docs||[]).push([[9523],{158:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var a=t(6393);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(t),m=o,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||i;return t?a.createElement(h,r(r({ref:n},p),{},{components:t})):a.createElement(h,r({ref:n},p))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,r=new Array(i);r[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[d]="string"==typeof e?e:o,r[1]=s;for(var c=2;c<i;c++)r[c]=t[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},6810:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=t(9629),o=(t(6393),t(158));t(4532);const i={},r="Dependency Injection",s={unversionedId:"di",id:"di",title:"Dependency Injection",description:"Dependency Injection is a big topic but central to Hades development.",source:"@site/docs/guides/di.md",sourceDirName:".",slug:"/di",permalink:"/docs/guides/di",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"guides",previous:{title:"Guides",permalink:"/docs/guides/"},next:{title:"Writing SOLID Code",permalink:"/docs/guides/solid-code"}},l={},c=[{value:"What is it?",id:"what-is-it",level:2},{value:"Container Configuration",id:"container-configuration",level:2},{value:"Marking Types as Injectable",id:"marking-types-as-injectable",level:3},{value:"Requesting Instances",id:"requesting-instances",level:2},{value:"Injecting Instances",id:"injecting-instances",level:2},{value:"Dynamic Resolvers",id:"dynamic-resolvers",level:3},{value:"Lifetimes",id:"lifetimes",level:3},{value:"Targetted Bindings",id:"targetted-bindings",level:3}],p={toc:c};function d(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"dependency-injection"},"Dependency Injection"),(0,o.kt)("p",null,"Dependency Injection is a big topic but central to Hades development."),(0,o.kt)("p",null,"If you're unsure about why you should care, the definitive resource is ",(0,o.kt)("a",{parentName:"p",href:"https://www.amazon.com/Dependency-Injection-NET-Mark-Seemann/dp/1935182501"},"Dependency Injection by MarkSeeman"),"\nbut feel free to just google it."),(0,o.kt)("p",null,"The DI container described in this document is based on\n",(0,o.kt)("a",{parentName:"p",href:"https://inversify.io/"},"Inversify.js"),", but the concepts are the same for just about any modern container."),(0,o.kt)("h2",{id:"what-is-it"},"What is it?"),(0,o.kt)("p",null,"DI is all about fetching ",(0,o.kt)("em",{parentName:"p"},"instances")," of things:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Instances of some ",(0,o.kt)("em",{parentName:"li"},"concrete type")),(0,o.kt)("li",{parentName:"ul"},"Instances of some ",(0,o.kt)("em",{parentName:"li"},"concrete type")," which ",(0,o.kt)("em",{parentName:"li"},"implements some interface"))),(0,o.kt)("p",null,"After telling the DI container how create instances of our types, it takes on the\nrole of passing them to the code they're needed by."),(0,o.kt)("p",null,"Your code ",(0,o.kt)("em",{parentName:"p"},"depends")," on instances of those types. The container ",(0,o.kt)("em",{parentName:"p"},"injects")," them."),(0,o.kt)("p",null,'\u21b3 "dependency injection"'),(0,o.kt)("h2",{id:"container-configuration"},"Container Configuration"),(0,o.kt)("p",null,"Configuring the DI container consists of telling it how to make instances of types and interfaces."),(0,o.kt)("p",null,"If you'll ever want an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"Foo"),", you have to, ahead of time, tell the container ",(0,o.kt)("em",{parentName:"p"},"how")," to provide it. If you want an instance of some type which extends ",(0,o.kt)("inlineCode",{parentName:"p"},"Useful"),", then you have to previously have told the container ",(0,o.kt)("em",{parentName:"p"},"how to provide it"),"."),(0,o.kt)("p",null,'The way you tell the container how to do this is by "binding" the desired types to the way of making obtaining them:'),(0,o.kt)("p",null,"The basic pattern: ",(0,o.kt)("inlineCode",{parentName:"p"},"container.bind(WHAT).to(HOW)")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Constant values"),": "),(0,o.kt)("p",null,"With constant values, we provide the value that will be bound to the type."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"container\n  .bind(Foo)\n  .toConstantValue(new Foo())\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Constructors"),": "),(0,o.kt)("p",null,"With constructors, we let the container call the type's constructor to create the new instance."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"container\n  .bind(Foo)\n  .toSelf()\n\ncontainer // from base class to implementor\n  .bind(Useful)\n  .to(Foo)\n")),(0,o.kt)("p",null,"There are actually many ways to do binding in Inversify.js. ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/inversify/InversifyJS/blob/master/wiki/readme.md#the-inversifyjs-features-and-api"},"Check out the docs."),"."),(0,o.kt)("h3",{id:"marking-types-as-injectable"},"Marking Types as Injectable"),(0,o.kt)("p",null,"In order for our container bindings to work, we need to add the ",(0,o.kt)("inlineCode",{parentName:"p"},"@injectable()"),"\ndecorator to our class:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@injectable()\nclass Foo { /* ... */ }\n")),(0,o.kt)("h2",{id:"requesting-instances"},"Requesting Instances"),(0,o.kt)("p",null,"Once the container knows how to produce instances of our ",(0,o.kt)("inlineCode",{parentName:"p"},"@injectable()"),"\ndecorated types, your code can request them. If your code ",(0,o.kt)("em",{parentName:"p"},"depended")," on using an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"Foo"),", it could ask the container for one:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"var foo = container.get(Foo);\n")),(0,o.kt)("p",null,"Similarly, if your code depended on having an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"Useful")," but didn't care which implementation is used, it can again ask the container:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"var useful = container.get(Useful)\n")),(0,o.kt)("p",null,"In this case, the container would create an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"Foo")," since we told it to bind ",(0,o.kt)("inlineCode",{parentName:"p"},"Useful")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"Foo"),"."),(0,o.kt)("h2",{id:"injecting-instances"},"Injecting Instances"),(0,o.kt)("p",null,"For types with no constructor parameters (no dependencies), the container can\neasily instantiate it by calling the constructor."),(0,o.kt)("p",null,"But what if ",(0,o.kt)("inlineCode",{parentName:"p"},"Foo")," has its ",(0,o.kt)("em",{parentName:"p"},"own")," dependencies?"),(0,o.kt)("p",null,"You can tell the container how to resolve ",(0,o.kt)("inlineCode",{parentName:"p"},"Foo"),"'s dependencies by decorating\nits constructor's parameters with ",(0,o.kt)("inlineCode",{parentName:"p"},"@inject()"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@injectable()\nclass Foo {\n    constructor(\n        @inject(ILogger) logger: ILogger,\n        @inject(Number) randomNum: Number\n    ) {\n        // ...\n    }\n}\n")),(0,o.kt)("p",null,"The container can now call ",(0,o.kt)("inlineCode",{parentName:"p"},"Foo"),"'s constructor as we've told it which types the\nparameters are bound to. The container simply makes instances of those first,\nand then passes them to ",(0,o.kt)("inlineCode",{parentName:"p"},"Foo"),"s constructor. If the parameters have constructor\nparameters of their own, the container can in turn satisfy those dependencies\ntoo -- as long as all the required types and interfaces have been bound and\nmarked."),(0,o.kt)("p",null,"Properly configured, a DI container can produce your program's entire object graph"),(0,o.kt)("h3",{id:"dynamic-resolvers"},"Dynamic Resolvers"),(0,o.kt)("p",null,"In a way, a concrete type's constructor can be thought of a factory - in that new instances can be made by calling it."),(0,o.kt)("p",null,"However, what if the container can't provide all of the constructor parameters\nfor a given type? Say we don't have a binding to use with ",(0,o.kt)("inlineCode",{parentName:"p"},"@inject()"),"? Instead, we must provide a factory function that helps the container do the work of providing those unbound dependencies."),(0,o.kt)("p",null,"If ",(0,o.kt)("inlineCode",{parentName:"p"},"Foo")," takes an ",(0,o.kt)("inlineCode",{parentName:"p"},"ILogger")," and an ",(0,o.kt)("inlineCode",{parentName:"p"},"Number")," we can assume the ",(0,o.kt)("inlineCode",{parentName:"p"},"ILogger")," interface is bound usefully. However, instead of binding ",(0,o.kt)("inlineCode",{parentName:"p"},"Number")," in the container, we can instead bind ",(0,o.kt)("inlineCode",{parentName:"p"},"Foo")," to a dynamic resolver, which is just a simple lambda function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"container\n  .bind(Foo)\n  .toDynamicValue((context: Context) => {\n      var di = context.container;\n      var logger = container.get(ILogger);\n      return new Foo(logger, randomNumber());\n  })\n  .inSingletonScope();\n")),(0,o.kt)("p",null,"When the container must produce an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"Foo")," it will call this\nfunction. The function uses the container to resolve the ",(0,o.kt)("inlineCode",{parentName:"p"},"ILogger"),"\ndependency. But we're telling it how to provide the ",(0,o.kt)("inlineCode",{parentName:"p"},"Number")," dependency (",(0,o.kt)("inlineCode",{parentName:"p"},"randomNumber()"),")."),(0,o.kt)("p",null,"In this case, the container will only ever call the function once, to produce a\nsingle instance, and always return that one. This is thanks to binding ",(0,o.kt)("inlineCode",{parentName:"p"},"Foo"),"\nwith ",(0,o.kt)("inlineCode",{parentName:"p"},"inSingletonScope()")," which we'll cover in the next section."),(0,o.kt)("h3",{id:"lifetimes"},"Lifetimes"),(0,o.kt)("p",null,'You can specify the "scope" or "lifetime" of a binding with an extra method\nafter the ',(0,o.kt)("inlineCode",{parentName:"p"},".to()")," clause of a binding:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},".inTransientScope()")," : A new instance is created for every need"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},".inSingletonScope()")," : A single instance is used for every need")),(0,o.kt)("p",null,"In the above example, by changing the lifetime to transient, a new random number is produced each time an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"Foo")," is provided:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"container\n  .bind(Foo)\n  .toDynamicValue((context: Context) => {\n      var di = context.container;\n      var logger = container.get(ILogger);\n      return new Foo(logger, randomNumber());\n  })\n  .inTransientScope();\n")),(0,o.kt)("p",null,"Transient is the default however, so this is unnecessary."),(0,o.kt)("h3",{id:"targetted-bindings"},"Targetted Bindings"),(0,o.kt)("p",null,"Another way to inject ",(0,o.kt)("inlineCode",{parentName:"p"},"Foo")," with a ",(0,o.kt)("inlineCode",{parentName:"p"},"Number")," is by targetting a specific binding\nto it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"container\n  .bind(Number)\n  .toDynamicValue(context: Context => randomNumber())\n  .whenInjectedInto(Foo);\n")),(0,o.kt)("p",null,"In this case, we've created a binding for ",(0,o.kt)("inlineCode",{parentName:"p"},"Number")," which is only used when\nsatisfying the dependency for ",(0,o.kt)("inlineCode",{parentName:"p"},"Foo"),"."))}d.isMDXComponent=!0},4532:(e,n,t)=>{t(6393)}}]);