"use strict";(self.webpackChunk_hades_ts_docs=self.webpackChunk_hades_ts_docs||[]).push([[8133],{2677:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"di","title":"Dependency Injection","description":"Dependency Injection is a big topic but central to Hades development.","source":"@site/docs/guides/di.md","sourceDirName":".","slug":"/di","permalink":"/docs/guides/di","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"guides","previous":{"title":"Writing SOLID Code","permalink":"/docs/guides/solid-code"},"next":{"title":"Ejecting Bots","permalink":"/docs/guides/ejecting-a-bot"}}');var s=t(5723),o=t(4987);const c={},r="Dependency Injection",a={},d=[{value:"What is it?",id:"what-is-it",level:2},{value:"Container Configuration",id:"container-configuration",level:2},{value:"Marking Types as Injectable",id:"marking-types-as-injectable",level:3},{value:"Requesting Instances",id:"requesting-instances",level:2},{value:"Injecting Instances",id:"injecting-instances",level:2},{value:"Dynamic Resolvers",id:"dynamic-resolvers",level:3},{value:"Lifetimes",id:"lifetimes",level:3},{value:"Targetted Bindings",id:"targetted-bindings",level:3}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"dependency-injection",children:"Dependency Injection"})}),"\n",(0,s.jsx)(n.p,{children:"Dependency Injection is a big topic but central to Hades development."}),"\n",(0,s.jsxs)(n.p,{children:["If you're unsure about why you should care, the definitive resource is ",(0,s.jsx)(n.a,{href:"https://www.amazon.com/Dependency-Injection-NET-Mark-Seemann/dp/1935182501",children:"Dependency Injection by MarkSeeman"}),"\nbut feel free to just google it."]}),"\n",(0,s.jsxs)(n.p,{children:["The DI container described in this document is based on\n",(0,s.jsx)(n.a,{href:"https://inversify.io/",children:"Inversify.js"}),", but the concepts are the same for just about any modern container."]}),"\n",(0,s.jsx)(n.h2,{id:"what-is-it",children:"What is it?"}),"\n",(0,s.jsxs)(n.p,{children:["DI is all about fetching ",(0,s.jsx)(n.em,{children:"instances"})," of things:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Instances of some ",(0,s.jsx)(n.em,{children:"concrete type"})]}),"\n",(0,s.jsxs)(n.li,{children:["Instances of some ",(0,s.jsx)(n.em,{children:"concrete type"})," which ",(0,s.jsx)(n.em,{children:"implements some interface"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"After telling the DI container how create instances of our types, it takes on the\nrole of passing them to the code they're needed by."}),"\n",(0,s.jsxs)(n.p,{children:["Your code ",(0,s.jsx)(n.em,{children:"depends"})," on instances of those types. The container ",(0,s.jsx)(n.em,{children:"injects"})," them."]}),"\n",(0,s.jsx)(n.p,{children:'\u21b3 "dependency injection"'}),"\n",(0,s.jsx)(n.h2,{id:"container-configuration",children:"Container Configuration"}),"\n",(0,s.jsx)(n.p,{children:"Configuring the DI container consists of telling it how to make instances of types and interfaces."}),"\n",(0,s.jsxs)(n.p,{children:["If you'll ever want an instance of ",(0,s.jsx)(n.code,{children:"Foo"}),", you have to, ahead of time, tell the container ",(0,s.jsx)(n.em,{children:"how"})," to provide it. If you want an instance of some type which extends ",(0,s.jsx)(n.code,{children:"Useful"}),", then you have to previously have told the container ",(0,s.jsx)(n.em,{children:"how to provide it"}),"."]}),"\n",(0,s.jsx)(n.p,{children:'The way you tell the container how to do this is by "binding" the desired types to the way of making obtaining them:'}),"\n",(0,s.jsxs)(n.p,{children:["The basic pattern: ",(0,s.jsx)(n.code,{children:"container.bind(WHAT).to(HOW)"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Constant values"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"With constant values, we provide the value that will be bound to the type."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"container.bind(Foo).toConstantValue(new Foo());\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Constructors"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"With constructors, we let the container call the type's constructor to create the new instance."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"container.bind(Foo).toSelf();\n\ncontainer // from base class to implementor\n  .bind(Useful)\n  .to(Foo);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["There are actually many ways to do binding in Inversify.js. ",(0,s.jsx)(n.a,{href:"https://github.com/inversify/InversifyJS/blob/master/wiki/readme.md#the-inversifyjs-features-and-api",children:"Check out the docs."}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"marking-types-as-injectable",children:"Marking Types as Injectable"}),"\n",(0,s.jsxs)(n.p,{children:["In order for our container bindings to work, we need to add the ",(0,s.jsx)(n.code,{children:"@injectable()"}),"\ndecorator to our class:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"@injectable()\nclass Foo {\n  /* ... */\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"requesting-instances",children:"Requesting Instances"}),"\n",(0,s.jsxs)(n.p,{children:["Once the container knows how to produce instances of our ",(0,s.jsx)(n.code,{children:"@injectable()"}),"\ndecorated types, your code can request them. If your code ",(0,s.jsx)(n.em,{children:"depended"})," on using an instance of ",(0,s.jsx)(n.code,{children:"Foo"}),", it could ask the container for one:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",children:"var foo = container.get(Foo);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Similarly, if your code depended on having an instance of ",(0,s.jsx)(n.code,{children:"Useful"})," but didn't care which implementation is used, it can again ask the container:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",children:"var useful = container.get(Useful)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this case, the container would create an instance of ",(0,s.jsx)(n.code,{children:"Foo"})," since we told it to bind ",(0,s.jsx)(n.code,{children:"Useful"})," to ",(0,s.jsx)(n.code,{children:"Foo"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"injecting-instances",children:"Injecting Instances"}),"\n",(0,s.jsx)(n.p,{children:"For types with no constructor parameters (no dependencies), the container can\neasily instantiate it by calling the constructor."}),"\n",(0,s.jsxs)(n.p,{children:["But what if ",(0,s.jsx)(n.code,{children:"Foo"})," has its ",(0,s.jsx)(n.em,{children:"own"})," dependencies?"]}),"\n",(0,s.jsxs)(n.p,{children:["You can tell the container how to resolve ",(0,s.jsx)(n.code,{children:"Foo"}),"'s dependencies by decorating\nits constructor's parameters with ",(0,s.jsx)(n.code,{children:"@inject()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"@injectable()\nclass Foo {\n  constructor(\n    @inject(ILogger) logger: ILogger,\n    @inject(Number) randomNum: Number,\n  ) {\n    // ...\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The container can now call ",(0,s.jsx)(n.code,{children:"Foo"}),"'s constructor as we've told it which types the\nparameters are bound to. The container simply makes instances of those first,\nand then passes them to ",(0,s.jsx)(n.code,{children:"Foo"}),"s constructor. If the parameters have constructor\nparameters of their own, the container can in turn satisfy those dependencies\ntoo -- as long as all the required types and interfaces have been bound and\nmarked."]}),"\n",(0,s.jsx)(n.p,{children:"Properly configured, a DI container can produce your program's entire object graph"}),"\n",(0,s.jsx)(n.h3,{id:"dynamic-resolvers",children:"Dynamic Resolvers"}),"\n",(0,s.jsx)(n.p,{children:"In a way, a concrete type's constructor can be thought of a factory - in that new instances can be made by calling it."}),"\n",(0,s.jsxs)(n.p,{children:["However, what if the container can't provide all of the constructor parameters\nfor a given type? Say we don't have a binding to use with ",(0,s.jsx)(n.code,{children:"@inject()"}),"? Instead, we must provide a factory function that helps the container do the work of providing those unbound dependencies."]}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"Foo"})," takes an ",(0,s.jsx)(n.code,{children:"ILogger"})," and an ",(0,s.jsx)(n.code,{children:"Number"})," we can assume the ",(0,s.jsx)(n.code,{children:"ILogger"})," interface is bound usefully. However, instead of binding ",(0,s.jsx)(n.code,{children:"Number"})," in the container, we can instead bind ",(0,s.jsx)(n.code,{children:"Foo"})," to a dynamic resolver, which is just a simple lambda function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"container\n  .bind(Foo)\n  .toDynamicValue((context: Context) => {\n    var di = context.container;\n    var logger = container.get(ILogger);\n    return new Foo(logger, randomNumber());\n  })\n  .inSingletonScope();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When the container must produce an instance of ",(0,s.jsx)(n.code,{children:"Foo"})," it will call this\nfunction. The function uses the container to resolve the ",(0,s.jsx)(n.code,{children:"ILogger"}),"\ndependency. But we're telling it how to provide the ",(0,s.jsx)(n.code,{children:"Number"})," dependency (",(0,s.jsx)(n.code,{children:"randomNumber()"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["In this case, the container will only ever call the function once, to produce a\nsingle instance, and always return that one. This is thanks to binding ",(0,s.jsx)(n.code,{children:"Foo"}),"\nwith ",(0,s.jsx)(n.code,{children:"inSingletonScope()"})," which we'll cover in the next section."]}),"\n",(0,s.jsx)(n.h3,{id:"lifetimes",children:"Lifetimes"}),"\n",(0,s.jsxs)(n.p,{children:['You can specify the "scope" or "lifetime" of a binding with an extra method\nafter the ',(0,s.jsx)(n.code,{children:".to()"})," clause of a binding:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:".inTransientScope()"})," : A new instance is created for every need"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:".inSingletonScope()"})," : A single instance is used for every need"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In the above example, by changing the lifetime to transient, a new random number is produced each time an instance of ",(0,s.jsx)(n.code,{children:"Foo"})," is provided:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"container\n  .bind(Foo)\n  .toDynamicValue((context: Context) => {\n    var di = context.container;\n    var logger = container.get(ILogger);\n    return new Foo(logger, randomNumber());\n  })\n  .inTransientScope();\n"})}),"\n",(0,s.jsx)(n.p,{children:"Transient is the default however, so this is unnecessary."}),"\n",(0,s.jsx)(n.h3,{id:"targetted-bindings",children:"Targetted Bindings"}),"\n",(0,s.jsxs)(n.p,{children:["Another way to inject ",(0,s.jsx)(n.code,{children:"Foo"})," with a ",(0,s.jsx)(n.code,{children:"Number"})," is by targetting a specific binding\nto it:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"container\n  .bind(Number)\n  .toDynamicValue(context: Context => randomNumber())\n  .whenInjectedInto(Foo);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this case, we've created a binding for ",(0,s.jsx)(n.code,{children:"Number"})," which is only used when\nsatisfying the dependency for ",(0,s.jsx)(n.code,{children:"Foo"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},4987:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>r});var i=t(2155);const s={},o=i.createContext(s);function c(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);